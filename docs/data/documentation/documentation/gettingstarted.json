{"primaryContentSections":[{"kind":"content","content":[{"anchor":"Overview","level":2,"type":"heading","text":"Overview"},{"type":"paragraph","inlineContent":[{"type":"text","text":"SwiftUI Hooks is a SwiftUI implementation of React Hooks. Brings the state and lifecycle into the function view, without depending on elements that are only allowed to be used in struct views such as @State or @ObservedObject. It allows you to reuse stateful logic between views by building custom hooks composed with multiple hooks. Furthermore, hooks such as useEffect also solve the problem of lack of lifecycles in SwiftUI."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Code Sample"}]},{"anchor":"How-do-you-use-a-Hook-function","level":2,"type":"heading","text":"How do you use a Hook function?"},{"anchor":"useState","level":3,"type":"heading","text":"useState"},{"type":"codeListing","syntax":"swift","code":["func useState<State>(_ initialState: State) -> Binding<State>","func useState<State>(_ initialState: @escaping () -> State) -> Binding<State>"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"A hook to use a Binding"},{"type":"text","text":" wrapping current state to be updated by setting a new state to wrappedValue."},{"type":"text","text":" "},{"type":"text","text":"Triggers a view update when the state has been changed."}]},{"type":"codeListing","syntax":"swift","code":["","let count = useState(0)  \/\/ Binding<Int>","","Button(\"Increment\") {","  count.wrappedValue += 1","}",""]},{"type":"paragraph","inlineContent":[{"type":"text","text":"If the initial state is the result of an expensive computation, you may provide a closure instead. The closure will be executed once, during the initial render."}]},{"type":"codeListing","syntax":"swift","code":["let count = useState {","let initialState = expensiveComputation() \/\/ Int","  return initialState","}                                             \/\/ Binding<Int>","","Button(\"Increment\") {","  count.wrappedValue += 1","}",""]},{"anchor":"useEffect","level":3,"type":"heading","text":"useEffect"},{"type":"codeListing","syntax":"swift","code":["func useEffect(","_ updateStrategy: HookUpdateStrategy? = nil,","_ effect: @escaping () -> (() -> Void)?",")"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"A hook to use a side effect function that is called the number of times according to the strategy specified with updateStrategy."},{"type":"text","text":" "},{"type":"text","text":"Optionally the function can be cancelled when this hook is disposed or when the side-effect function is called again."},{"type":"text","text":" "},{"type":"text","text":"Note that the execution is deferred until after ohter hooks have been updated."}]},{"type":"codeListing","syntax":"swift","code":["useEffect {","  print(\"Do side effects\")","","  return {","    print(\"Do cleanup\")","  }","}",""]},{"anchor":"useLayoutEffect","level":3,"type":"heading","text":"useLayoutEffect"},{"type":"codeListing","syntax":"swift","code":["func useLayoutEffect(","_ updateStrategy: HookUpdateStrategy? = nil,","_ effect: @escaping () -> (() -> Void)?",")"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"A hook to use a side effect function that is called the number of times according to the strategy specified with updateStrategy."},{"type":"text","text":" "},{"type":"text","text":"Optionally the function can be cancelled when this hook is unmount from the view tree or when the side-effect function is called again."},{"type":"text","text":" "},{"type":"text","text":"The signature is identical to useEffect, but this fires synchronously when the hook is called."}]},{"type":"codeListing","syntax":"swift","code":["useLayoutEffect {","  print(\"Do side effects\")","  return nil","}",""]},{"anchor":"useMemo","level":3,"type":"heading","text":"useMemo"},{"type":"codeListing","syntax":"swift","code":["func useMemo<Value>(","_ updateStrategy: HookUpdateStrategy,","_ makeValue: @escaping () -> Value",") -> Value"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"A hook to use memoized value preserved until it is updated at the timing determined with given updateStrategy."}]},{"type":"codeListing","syntax":"swift","code":["let random = useMemo(.once) {","  Int.random(in: 0...100)","}"]},{"anchor":"useRef","level":3,"type":"heading","text":"useRef"},{"type":"codeListing","syntax":"swift","code":["func useRef<T>(_ initialValue: T) -> RefObject<T>"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"A hook to use a mutable ref object storing an arbitrary value."},{"type":"text","text":" "},{"type":"text","text":"The essential of this hook is that setting a value to current doesnâ€™t trigger a view update."}]},{"type":"codeListing","syntax":"swift","code":["let value = useRef(\"text\")  \/\/ RefObject<String>","","Button(\"Save text\") {","  value.current = \"new text\"","}",""]},{"anchor":"useReducer","level":3,"type":"heading","text":"useReducer"},{"type":"codeListing","syntax":"swift","code":["func useReducer<State, Action>(","_ reducer: @escaping (State, Action) -> State,","initialState: State",") -> (state: State, dispatch: (Action) -> Void)",""]},{"type":"paragraph","inlineContent":[{"type":"text","text":"A hook to use the state returned by the passed reducer, and a dispatch function to send actions to update the state."},{"type":"text","text":" "},{"type":"text","text":"Triggers a view update when the state has been changed."}]},{"type":"codeListing","syntax":"swift","code":["enum Action {","  case increment, decrement","}","","func reducer(state: Int, action: Action) -> Int {","  switch action {","    case .increment:","      return state + 1","","    case .decrement:","      return state - 1","  }","}","","let (count, dispatch) = useReducer(reducer, initialState: 0)"]},{"anchor":"useAsync","level":3,"type":"heading","text":"useAsync"},{"type":"codeListing","syntax":"swift","code":["","func useAsync<Output>(","_ updateStrategy: HookUpdateStrategy,","_ operation: @escaping () async -> Output",") -> AsyncPhase<Output, Never>","","func useAsync<Output>(","_ updateStrategy: HookUpdateStrategy,","_ operation: @escaping () async throws -> Output",") -> AsyncPhase<Output, Error>",""]},{"type":"paragraph","inlineContent":[{"type":"text","text":"A hook to use the most recent phase of asynchronous operation of the passed function."},{"type":"text","text":" "},{"type":"text","text":"The function will be performed at the first update and will be re-performed according to the given updateStrategy."}]},{"type":"codeListing","syntax":"swift","code":["let phase = useAsync(.once) {","  try await URLSession.shared.data(from: url)","}"]},{"anchor":"useAsyncPerform","level":3,"type":"heading","text":"useAsyncPerform"},{"type":"codeListing","syntax":"swift","code":["func useAsyncPerform<Output>(","_ operation: @escaping @MainActor () async -> Output",") -> (phase: AsyncPhase<Output, Never>, perform: @MainActor () async -> Void)","","func useAsyncPerform<Output>(","_ operation: @escaping @MainActor () async throws -> Output",") -> (phase: AsyncPhase<Output, Error>, perform: @MainActor () async -> Void)",""]},{"type":"paragraph","inlineContent":[{"type":"text","text":"A hook to use the most recent phase of the passed asynchronous operation, and a perform function to call the it at arbitrary timing."}]},{"type":"codeListing","syntax":"swift","code":["let (phase, perform) = useAsyncPerform {","  try await URLSession.shared.data(from: url)","}",""]},{"anchor":"usePublisher","level":3,"type":"heading","text":"usePublisher"},{"type":"codeListing","syntax":"swift","code":["func usePublisher<P: Publisher>(","_ updateStrategy: HookUpdateStrategy,","_ makePublisher: @escaping () -> P",") -> AsyncPhase<P.Output, P.Failure>",""]},{"type":"paragraph","inlineContent":[{"type":"text","text":"A hook to use the most recent phase of asynchronous operation of the passed publisher."},{"type":"text","text":" "},{"type":"text","text":"The publisher will be subscribed at the first update and will be re-subscribed according to the given updateStrategy."}]},{"type":"codeListing","syntax":"swift","code":["let phase = usePublisher(.once) {","  URLSession.shared.dataTaskPublisher(for: url)","}"]},{"anchor":"usePublisherSubscribe","level":3,"type":"heading","text":"usePublisherSubscribe"},{"type":"codeListing","syntax":"swift","code":["func usePublisherSubscribe<P: Publisher>(","_ makePublisher: @escaping () -> P",") -> (phase: AsyncPhase<P.Output, P.Failure>, subscribe: () -> Void)",""]},{"type":"paragraph","inlineContent":[{"type":"text","text":"A hook to use the most recent phase of asynchronous operation of the passed publisher, and a subscribe function to subscribe to it at arbitrary timing."}]},{"type":"codeListing","syntax":"swift","code":["let (phase, subscribe) = usePublisherSubscribe {","  URLSession.shared.dataTaskPublisher(for: url)","}"]},{"anchor":"useEnvironment","level":3,"type":"heading","text":"useEnvironment"},{"type":"codeListing","syntax":"swift","code":["func useEnvironment<Value>(_ keyPath: KeyPath<EnvironmentValues, Value>) -> Value"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"A hook to use environment value passed through the view tree without @Environment property wrapper."}]},{"type":"codeListing","syntax":"swift","code":["let colorScheme = useEnvironment(\\.colorScheme)  \/\/ ColorScheme",""]},{"type":"codeListing","syntax":"swift","code":["func useContext<T>(_ context: Context<T>.Type) -> T"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"A hook to use current context value that is provided by Context"},{"type":"text","text":".Provider."},{"type":"text","text":" "},{"type":"text","text":"The purpose is identical to use Context"},{"type":"text","text":".Consumer."},{"type":"text","text":" "},{"type":"text","text":"See Context section for more details."}]},{"type":"codeListing","syntax":"swift","code":["let value = useContext(Context<Int>.self)  \/\/ Int"]}]}],"schemaVersion":{"major":0,"minor":3,"patch":0},"sections":[],"variants":[{"paths":["\/documentation\/documentation\/gettingstarted"],"traits":[{"interfaceLanguage":"swift"}]}],"identifier":{"url":"doc:\/\/Documentation\/documentation\/Documentation\/GettingStarted","interfaceLanguage":"swift"},"abstract":[{"type":"text","text":"A SwiftUI implementation of React Hooks. Enhances reusability of stateful logic and gives state and lifecycle to function view."}],"kind":"article","metadata":{"roleHeading":"Article","title":"Getting Started with Hooks","role":"article","modules":[{"name":"Documentation"}]},"hierarchy":{"paths":[["doc:\/\/Documentation\/documentation\/Documentation"]]},"references":{"doc://Documentation/documentation/Documentation":{"role":"collection","title":"Documentation","abstract":[{"type":"text","text":"A SwiftUI implementation of React Hooks. Enhances reusability of stateful logic and gives state and lifecycle to function view."}],"identifier":"doc:\/\/Documentation\/documentation\/Documentation","kind":"symbol","type":"topic","url":"\/documentation\/documentation"}}}